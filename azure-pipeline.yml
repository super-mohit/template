trigger:
  branches:
    include:
      - 'test-deploy'
 
 
pool:
  vmImage: 'ubuntu-latest'
 
steps:
# -------------------------------------------------
# Step 1 ‚Äì Generate Tag Name (publish outputs)
# -------------------------------------------------
- script: |
    # ---------- Gather data ----------
    COMMIT_ID=$(git rev-parse --short=7 HEAD)
    AUTHOR_NAME=$(git log -1 --pretty=format:"%an")
    DATE=$(date +'%Y%m%d')
 
    # Full branch reference (e.g. refs/heads/feature/foo)
    CURRENT_BRANCH="$(Build.SourceBranchName)"
    # Clean branch (without the refs/heads/ prefix) - kept for possible other uses
    CLEAN_BRANCH=$(echo "$CURRENT_BRANCH" | sed 's|refs/heads/||')
 
    # Use Azure DevOps built-in build number instead of querying API
    BUILD_ID="$(Build.BuildId)"
 
    # ---------- Create tag ----------
    TAG_NAME="${AUTHOR_NAME// /_}-${DATE}-${COMMIT_ID}-${BUILD_ID}"
    echo "##vso[task.setvariable variable=TAG_NAME;isOutput=true]$TAG_NAME"
    echo "##vso[task.setvariable variable=AUTHOR_NAME;isOutput=true]${AUTHOR_NAME}"
    echo "##vso[task.setvariable variable=CLEAN_BRANCH;isOutput=true]$CLEAN_BRANCH"
    echo "##vso[task.setvariable variable=CURRENT_BRANCH;isOutput=true]$CURRENT_BRANCH"
 
    echo "Generated Tag: $TAG_NAME"
    echo "Full branch (CURRENT_BRANCH): $CURRENT_BRANCH"
    echo "Clean branch (CLEAN_BRANCH): $CLEAN_BRANCH"
    echo "Author: $AUTHOR_NAME"
    echo "Build ID: $BUILD_ID"
  name: GenerateTag               # reference name for outputs
  displayName: 'Step 1 - Generate Tag Name'
 
# -------------------------------------------------
# Step 1.4 ‚Äì Quick Check: Images were pushed to which registry?
# -------------------------------------------------
- bash: |
    echo "Images will be pushed via service connection: svai-dev-acr_supportingtools_conn"
    echo "After this pipeline runs, check the Docker@2 task output above to see the actual registry URL used."
  displayName: 'Step 1.4 - Docker Registry Info'
 
# -------------------------------------------------
# Step 1.5 ‚Äì Build and Push Docker Images (Backend & Frontend)
# -------------------------------------------------
- bash: |
    # Locate Dockerfiles and build contexts for this codebase
    BACKEND_DOCKERFILE=""
    BACKEND_BUILD_CONTEXT=""
    FRONTEND_DOCKERFILE=""
    FRONTEND_BUILD_CONTEXT=""
    
    # Backend is at root level
    if [ -f "$(Build.SourcesDirectory)/Dockerfile" ] && [ -d "$(Build.SourcesDirectory)/packages" ]; then
      BACKEND_DOCKERFILE="$(Build.SourcesDirectory)/Dockerfile"
      BACKEND_BUILD_CONTEXT="$(Build.SourcesDirectory)"
      echo "‚úì Backend Dockerfile found at root with packages folder"
    else
      echo "‚úó Backend Dockerfile not found or packages folder missing"
    fi
    
    # Frontend is in frontend/ directory
    if [ -f "$(Build.SourcesDirectory)/frontend/Dockerfile" ]; then
      FRONTEND_DOCKERFILE="$(Build.SourcesDirectory)/frontend/Dockerfile"
      FRONTEND_BUILD_CONTEXT="$(Build.SourcesDirectory)/frontend"
      echo "‚úì Frontend Dockerfile found in frontend/"
    else
      echo "‚úó Frontend Dockerfile not found"
    fi
    
    echo "##vso[task.setvariable variable=BACKEND_DOCKERFILE]$BACKEND_DOCKERFILE"
    echo "##vso[task.setvariable variable=BACKEND_BUILD_CONTEXT]$BACKEND_BUILD_CONTEXT"
    echo "##vso[task.setvariable variable=FRONTEND_DOCKERFILE]$FRONTEND_DOCKERFILE"
    echo "##vso[task.setvariable variable=FRONTEND_BUILD_CONTEXT]$FRONTEND_BUILD_CONTEXT"
  displayName: 'Step 1.5.0 - Locate Dockerfiles and Build Contexts'
 
- task: Docker@2
  displayName: 'Step 1.5.1 - Build and Push Backend API Image'
  name: BuildBackend
  inputs:
    command: 'buildAndPush'
    containerRegistry: 'svai-dev-acr_supportingtools_conn'
    repository: 'ap-command-center'
    Dockerfile: '$(BACKEND_DOCKERFILE)'
    buildContext: '$(BACKEND_BUILD_CONTEXT)'
    tags: |
      $(GenerateTag.TAG_NAME)
      api-$(GenerateTag.TAG_NAME)
      latest
  condition: and(succeeded(), ne(variables['BACKEND_DOCKERFILE'], ''))
 
- bash: |
    echo "=== Detecting Azure Container Registry URL ==="
    
    # Method 1: Check docker images for the pushed image
    echo "Checking local Docker images..."
    FULL_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "ap-command-center" | head -1)
    echo "Found image: $FULL_IMAGE"
    
    # Extract registry URL (everything before the first /)
    REGISTRY_URL=""
    if [[ $FULL_IMAGE =~ ^([^/]+)/.* ]]; then
      REGISTRY_URL="${BASH_REMATCH[1]}"
      echo "‚úì Extracted from image: $REGISTRY_URL"
    fi
    
    # Method 2: Check Docker config for registry
    if [ -z "$REGISTRY_URL" ]; then
      echo "Checking Docker config..."
      if [ -f "$HOME/.docker/config.json" ]; then
        REGISTRY_URL=$(cat $HOME/.docker/config.json | grep -o '[^"]*\.azurecr\.io' | head -1)
        if [ -n "$REGISTRY_URL" ]; then
          echo "‚úì Found in Docker config: $REGISTRY_URL"
        fi
      fi
    fi
    
    # Method 3: List all images and try to find ACR pattern
    if [ -z "$REGISTRY_URL" ]; then
      echo "Searching all images for ACR pattern..."
      REGISTRY_URL=$(docker images --format "{{.Repository}}" | grep -o '[^/]*\.azurecr\.io' | head -1)
      if [ -n "$REGISTRY_URL" ]; then
        echo "‚úì Found ACR in images: $REGISTRY_URL"
      fi
    fi
    
    # Final check
    if [ -z "$REGISTRY_URL" ]; then
      echo "‚ùå Could not detect registry URL automatically"
      echo "Listing all images for debugging:"
      docker images | head -10
      exit 1
    fi
    
    echo ""
    echo "=== Final Registry URL: $REGISTRY_URL ==="
    echo "##vso[task.setvariable variable=ACR_URL;isOutput=true]$REGISTRY_URL"
  displayName: 'Step 1.5.1.5 - Auto-Detect Registry URL'
  name: ExtractACR
 
- task: Docker@2
  displayName: 'Step 1.5.2 - Build and Push Frontend UI Image'
  inputs:
    command: 'buildAndPush'
    containerRegistry: 'svai-dev-acr_supportingtools_conn'
    repository: 'ap-command-center-frontend'
    Dockerfile: '$(FRONTEND_DOCKERFILE)'
    buildContext: '$(FRONTEND_BUILD_CONTEXT)'
    tags: |
      $(GenerateTag.TAG_NAME)
      ui-$(GenerateTag.TAG_NAME)
      latest
  condition: and(succeeded(), ne(variables['FRONTEND_DOCKERFILE'], ''))
 
# -------------------------------------------------
# Step 2 ‚Äì Generate Kubernetes Resources
# -------------------------------------------------
- script: |
    # Get the TAG_NAME and CLEAN_BRANCH from the output variables of Step 1
    TAG_NAME="$(GenerateTag.TAG_NAME)"
    CLEAN_BRANCH="$(GenerateTag.CLEAN_BRANCH)"

    # Check if the TAG_NAME is set
    if [ -z "$TAG_NAME" ]; then
        echo "Error: TAG_NAME from the previous step is empty."
        exit 1
    fi

    # Check if the CLEAN_BRANCH is set
    if [ -z "$CLEAN_BRANCH" ]; then
        echo "Error: CLEAN_BRANCH from the previous step is empty."
        exit 1
    fi

    # Sanitize branch name for Kubernetes (replace / and other special chars with -)
    SANITIZED_BRANCH=$(echo "$CLEAN_BRANCH" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')

    echo "Using TAG_NAME: $TAG_NAME"
    echo "Using CLEAN_BRANCH: $CLEAN_BRANCH"
    echo "Using SANITIZED_BRANCH: $SANITIZED_BRANCH for deployment names"

    # Create dynamic deployment names
    FRONTEND_DEPLOYMENT="${SANITIZED_BRANCH}-ui"
    API_DEPLOYMENT="${SANITIZED_BRANCH}-api"

    echo "Frontend Deployment Name: $FRONTEND_DEPLOYMENT"
    echo "API Deployment Name: $API_DEPLOYMENT"

    # Get the registry URL that was auto-detected during Docker build
    ACR_URL="$(ExtractACR.ACR_URL)"
    
    if [ -z "$ACR_URL" ] || [ "$ACR_URL" == "" ]; then
      echo "‚ö†Ô∏è ERROR: ACR_URL not detected from Docker build step"
      echo "This should have been set by Step 1.5.1.5"
      exit 1
    fi
    
    echo "‚úì Using detected ACR URL: $ACR_URL"

    # Extract environment variables configuration
    echo "üìã Loading environment variables configuration..."
    
    # Check if k8s-env-config.txt exists, otherwise use defaults
    if [ -f "$(Build.SourcesDirectory)/config/k8s-env-config.txt" ]; then
      echo "‚úì Found config/k8s-env-config.txt, reading from file..."
      
      # Parse the config file
      FRONTEND_ENV_VARS=()
      BACKEND_ENV_VARS=()
      SECTION=""
      
      while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue
        
        # Check for section headers
        if [[ "$line" == "[FRONTEND]" ]]; then
          SECTION="FRONTEND"
          continue
        elif [[ "$line" == "[BACKEND]" ]]; then
          SECTION="BACKEND"
          continue
        fi
        
        # Add variable to appropriate array
        if [[ "$SECTION" == "FRONTEND" ]]; then
          FRONTEND_ENV_VARS+=("$line")
        elif [[ "$SECTION" == "BACKEND" ]]; then
          BACKEND_ENV_VARS+=("$line")
        fi
      done < "$(Build.SourcesDirectory)/config/k8s-env-config.txt"
    else
      echo "‚ö†Ô∏è config/k8s-env-config.txt not found, using defaults from docker-compose.yml..."
      
      # Frontend environment variables (from build args in docker-compose.yml)
      FRONTEND_ENV_VARS=(
        "NEXT_PUBLIC_API_URL"
        "NEXT_PUBLIC_BASE_PATH"
        "KEYCLOAK_SERVER_URL"
        "KEYCLOAK_REALM"
        "KEYCLOAK_CLIENT_ID"
        "KEYCLOAK_CLIENT_SECRET"
        "NEXTAUTH_SECRET"
        "NEXTAUTH_URL"
        "SUPERVITY_AUTH_DEBUG"
        "NEXT_PUBLIC_KEYCLOAK_URL"
        "APP_ENV"
        "NODE_ENV"
      )
      
      # Backend environment variables
      BACKEND_ENV_VARS=(
        "DATABASE_URL"
        "POSTGRES_USER"
        "POSTGRES_PASSWORD"
        "POSTGRES_DB"
        "APP_ENV"
        "CORS_ORIGINS"
        "AUTH_SECRET_KEY"
        "AUTH_ALGORITHM"
        "ACCESS_TOKEN_EXPIRE_MINUTES"
      )
    fi
    
    # Function to generate env vars for K8s
    generate_k8s_env_vars() {
      local env_array=("$@")
      for var in "${env_array[@]}"; do
        echo "            - name: $var"
      done
    }
    
    echo "‚úì Loaded ${#FRONTEND_ENV_VARS[@]} frontend env vars"
    echo "‚úì Loaded ${#BACKEND_ENV_VARS[@]} backend env vars"

    # Create Kubernetes deployment file
    cat <<EOF > k8s-deployment.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: ${FRONTEND_DEPLOYMENT}
      namespace: apcc
      labels:
        app: ${FRONTEND_DEPLOYMENT}
        branch: ${SANITIZED_BRANCH}
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: ${FRONTEND_DEPLOYMENT}
          svc: ${FRONTEND_DEPLOYMENT}-service
      template:
        metadata:
          creationTimestamp: null
          labels:
            app: ${FRONTEND_DEPLOYMENT}
            branch: ${SANITIZED_BRANCH}
            svc: ${FRONTEND_DEPLOYMENT}-service
        spec:
          containers:
          - name: ${FRONTEND_DEPLOYMENT}
            image: ${ACR_URL}/ap-command-center-frontend:${TAG_NAME}
            env:
    $(generate_k8s_env_vars "${FRONTEND_ENV_VARS[@]}")
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            imagePullPolicy: Always
            ports:
            - containerPort: 3000
          restartPolicy: Always
          terminationGracePeriodSeconds: 30
          dnsPolicy: ClusterFirst
          securityContext: {}
          imagePullSecrets:
          - name: suptools-acr
          schedulerName: default-scheduler
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxUnavailable: 25%
          maxSurge: 25%
      revisionHistoryLimit: 10
      progressDeadlineSeconds: 600
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: ${API_DEPLOYMENT}
      namespace: apcc
      labels:
        app: ${API_DEPLOYMENT}
        branch: ${SANITIZED_BRANCH}
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: ${API_DEPLOYMENT}
      template:
        metadata:
          creationTimestamp: null
          labels:
            app: ${API_DEPLOYMENT}
            branch: ${SANITIZED_BRANCH}
        spec:
          containers:
          - name: ${API_DEPLOYMENT}
            image: ${ACR_URL}/ap-command-center:${TAG_NAME}
            env:
    $(generate_k8s_env_vars "${BACKEND_ENV_VARS[@]}")
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            imagePullPolicy: IfNotPresent
            ports:
            - containerPort: 8000
          restartPolicy: Always
          terminationGracePeriodSeconds: 30
          dnsPolicy: ClusterFirst
          securityContext: {}
          imagePullSecrets:
          - name: suptools-acr
          schedulerName: default-scheduler
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxUnavailable: 25%
          maxSurge: 25%
      revisionHistoryLimit: 10
      progressDeadlineSeconds: 600
    EOF
 
    # Create Kubernetes service file
    cat <<EOF > k8s-service.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: ${FRONTEND_DEPLOYMENT}-service
      namespace: apcc
      labels:
        app: ${FRONTEND_DEPLOYMENT}
        branch: ${SANITIZED_BRANCH}
    spec:
      type: ClusterIP
      ports:
        - name: ${FRONTEND_DEPLOYMENT}-port
          protocol: TCP
          port: 3000
          targetPort: 3000
      selector:
        app: ${FRONTEND_DEPLOYMENT}
        svc: ${FRONTEND_DEPLOYMENT}-service
      sessionAffinity: None
      ipFamilies:
        - IPv4
      ipFamilyPolicy: SingleStack
      internalTrafficPolicy: Cluster
 
 
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: ${API_DEPLOYMENT}-service
      namespace: apcc
      labels:
        app: ${API_DEPLOYMENT}
        branch: ${SANITIZED_BRANCH}
    spec:
      type: ClusterIP
      ports:
        - name: ${API_DEPLOYMENT}-port
          protocol: TCP
          port: 8000
          targetPort: 8000
      selector:
        app: ${API_DEPLOYMENT}
        svc: ${API_DEPLOYMENT}-service
      sessionAffinity: None
      ipFamilies:
        - IPv4
      ipFamilyPolicy: SingleStack
      internalTrafficPolicy: Cluster
    EOF
 
    echo "Kubernetes deployment and service files created successfully."
  displayName: 'Step 2 - Generate Kubernetes Resources'
 
# -------------------------------------------------
# Step 2.5 ‚Äì Connect to AKS Cluster and Deploy
# -------------------------------------------------
- task: Kubernetes@1
  displayName: 'Step 2.5 - Deploy Deployment to AKS'
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: 'svai-dev-2-aks-democlustersvai-svc-conn'
    azureResourceGroup: 'supervity-demo'
    kubernetesCluster: 'demo_cluster_svai'
    namespace: 'apcc'
    command: 'apply'
    arguments: '-f k8s-deployment.yaml'
  condition: succeeded()
 
- task: Kubernetes@1
  displayName: 'Step 2.6 - Deploy Service to AKS'
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: 'svai-dev-2-aks-democlustersvai-svc-conn'
    azureResourceGroup: 'supervity-demo'
    kubernetesCluster: 'demo_cluster_svai'
    namespace: 'apcc'
    command: 'apply'
    arguments: '-f k8s-service.yaml'
  condition: succeeded()
 
# -------------------------------------------------
# Step 4 ‚Äì Create Ingress for the Branch Deployment
# -------------------------------------------------
- script: |
    # Get necessary variables from previous steps
    CLEAN_BRANCH="$(GenerateTag.CLEAN_BRANCH)"
    AUTHOR_NAME="$(GenerateTag.AUTHOR_NAME)"
 
    # Sanitize branch name for Kubernetes (replace / and other special chars with -)
    SANITIZED_BRANCH=$(echo "$CLEAN_BRANCH" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
 
    # Construct unique ingress name
    INGRESS_NAME="${SANITIZED_BRANCH}-ingress"
 
    # Define the base host for the ingress
    # IMPORTANT: Replace 'your.domain.com' with your actual domain or a placeholder for dynamic resolution
    INGRESS_HOST="demo.supervity.ai"
    FRONTEND_PATH_PREFIX="/apcc-${CLEAN_BRANCH}" # Use CLEAN_BRANCH for path as it's more readable
    API_PATH_PREFIX="/apcc-${CLEAN_BRANCH}/api"
 
    FRONTEND_SERVICE_NAME="${SANITIZED_BRANCH}-ui-service"
    API_SERVICE_NAME="${SANITIZED_BRANCH}-api-service"
 
    echo "Creating Ingress: $INGRESS_NAME"
    echo "Host: $INGRESS_HOST"
    echo "Frontend Path: $FRONTEND_PATH_PREFIX"
    echo "API Path: $API_PATH_PREFIX"
    echo "Frontend Service: $FRONTEND_SERVICE_NAME"
    echo "API Service: $API_SERVICE_NAME"
 
    # Create Kubernetes Ingress file
    cat <<EOF > k8s-ingress.yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: ${INGRESS_NAME}
      namespace: apcc # Ensure this matches your namespace
      labels:
        app.kubernetes.io/branch: ${SANITIZED_BRANCH}
    spec:
      ingressClassName: nginx
      tls:
        - hosts:
            - demo.supervity.ai
          secretName: cm-certs
      rules:
      - host: ${INGRESS_HOST}
        http:
          paths:
          - path: ${FRONTEND_PATH_PREFIX}
            pathType: Prefix
            backend:
              service:
                name: ${FRONTEND_SERVICE_NAME}
                port:
                  number: 3000
          - path: ${API_PATH_PREFIX}
            pathType: Prefix
            backend:
              service:
                name: ${API_SERVICE_NAME}
                port:
                  number: 8000
    EOF
 
    echo "Kubernetes Ingress file created successfully."
  displayName: 'Step 4 - Create Ingress for Branch Deployment'
  condition: succeeded()
  env:
    CLEAN_BRANCH: $(GenerateTag.CLEAN_BRANCH)
    AUTHOR_NAME: $(GenerateTag.AUTHOR_NAME)
 
- task: Kubernetes@1
  displayName: 'Step 4.1 - Apply Ingress to AKS'
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: 'svai-dev-2-aks-democlustersvai-svc-conn'
    azureResourceGroup: 'supervity-demo' # Replace with your resource group
    kubernetesCluster: 'demo_cluster_svai' # Replace with your cluster name
    namespace: 'apcc' # Ensure this matches your namespace
    command: 'apply'
    arguments: '-f k8s-ingress.yaml'
  condition: succeeded()
 
# -------------------------------------------------
# Step 5 ‚Äì Trivy Security Scan (REMOVED FOR DEBUGGING)
# -------------------------------------------------
# Trivy steps temporarily removed to debug Dockerfile path issues
 